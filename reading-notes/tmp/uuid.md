# UUID

参考链接：[知乎 小科普：通用唯一标识码UUID的介绍及使用](https://zhuanlan.zhihu.com/p/438580928)

## 一、UUID的定义

> 1. UUID是Universally Unique Identifier的缩写，即**通用表示码**。
> 2. UUID是由**一组32位数的16进制数字**所构成（16字节128位长的数字），是故UUID理论上的总数为16^32 = 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。
> 3. UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。
> 4. 它是在一定的范围内（从特定的名字空间到全球）唯一的机器生成的标识符。

## 二、UUID的作用

> 1. UUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。
>
>    **什么是分布式系统？**参考链接：[到底什么是分布式系统？你需要了解这些](https://zhuanlan.zhihu.com/p/228171977)
>
>    ​		简单的来说，**一个分布式系统是一组计算机系统一起工作，在终端用户看来，就像一台计算机在工作一样**。这组一起工作的计算机，拥有**共享的状态**，他们同时运行，独立机器的故障不会影响整个系统的正常运行。
>
>    ​		我们现在举个例子，传统的数据库是存储在一台机器的文件系统上的。每当我们取出或者插入信息的时候，我们直接和那台机器进行交互。那么现在我们把这个传统的数据库设计成**分布式数据库**。假设我们使用了**三台机器来构建这台分布式数据库，我们追求的结果是，在机器1上插入一条记录，需要在机器3上可以返回那条记录，当然了，机器1和2也要能够返回这条记录**。
>
> 2. 目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID）。

## 三、UUID的组成

> 1. UUID是指在一台机器上生成的数字，它保证对**在同一时空中的所有机器**都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。
> 2. UUID由以下几部分的组合：
>    - **当前日期和时间**，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
>    - **时钟序列**。
>    - **全局唯一的IEEE机器识别号**，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。

## 四、UUID的版本

### 1. UUID Version 1：基于时间的UUID

​		基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题。这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址。

- **Version-1变种1 – Hibernate**
- **Version-1变种2 – MongoDB**
- **Version-1变种3 – Twitter的snowflake派号器**（参考链接：https://jasonkayzk.github.io/2020/02/09/UUID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-UUID%E8%BF%98%E6%98%AFsnowflake/）

### 2. UUID Version 2：DCE安全的UUID

​		和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本实际中较少用到。

### 3. UUID Version 3：基于名字的UUID（MD5）

​		基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。

### 4. UUID Version 4：随机UUID

​		根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。

### 5. UUID Version 5：基于名字的UUID（SHA1）

​		和版本3的UUID算法类似，只是散列值计算使用SHA1（**Secure Hash Algorithm 1**）算法。

### 6. 总结：

​		从UUID的不同版本可以看出，**Version 1/2适合应用于分布式计算环境下**，具有高度的唯一性；**Version 3/5适合于一定范围内名字唯一，且需要或可能会重复生成UUID的环境下**；至于Version 4，我个人的建议是最好不用（虽然它是最简单最方便的）。

## 五、UUID、雪花ID、数据库自增主键

参考链接：[自增ID，UUID，雪花ID的使用](https://blog.csdn.net/whiteBearClimb/article/details/115481992)

[UUID&雪花ID&自增ID生成器在MySQL中的实操](https://blog.csdn.net/qq_37334150/article/details/116712905)

### 1. 数据库自增主键

1）自增主键不适用于**分库分表**情况，在做数据集合的时候会出现主键重复问题，做多个系统的数据汇总也会有冲突。

2）详情…删除…查询…这些接口如果都是依赖着自增主键做操作，很容易有安全性问题。

### 2. uuid

能解决自增id的安全性和数据汇总时候的问题，但是**效率不高**。

1）**uuid比较长**。为保证唯一性长度肯定比自增id长很多，批量提交，批量删除，批量查询的时候，list会非常大，传输数据这么大，对性能和带宽都会造成一定影响，get请求拼接在url上的话，过长甚至会被浏览器截断，url看上去也会很丑

2）**是完全乱序的**，新增一条新数据可能会打乱整棵索引树结构，它做主键索引也比自增ID做的主键索引占更大的空间。

3）索引：B+树的分裂，无序对修改影响很大。

### 3. 雪花id

解决了以上两者的问题，首先长度可以自定义限制，通过时间戳+机器号或者业务表单id+自增ID这样可以保证有序性。（雪花id和uuid二者差不多，但雪花ID完全可以替代UUID且相对较好）

> 雪花ID：1、64bit大小的整数（long类型）；2、可以按照时间的顺序有序生成；3、分布式相对自增ID不会产生ID碰撞（16bit工作机器ID）

## 六、雪花算法（snowflake）

> snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。

![preload](https://ask.qcloudimg.com/http-save/yehe-3899419/98qhcgg9ng.png)

**核心思想**：41bit作为毫秒数（2^41/1000/60/60/24/365 约等于 69年），10bit作为机器id（1024个节点，5个bit是数据中心，5个bit是机器id），12bit作为毫秒内的流水号（每毫秒4096个，每秒约生成2^12 = 409.6万个Aspi re pure 

不用连续自增。id），最后还有一个符号位，永远是0。

参考链接：[雪花算法(snowflake) ：分布式环境，生成全局唯一的订单号](https://blog.csdn.net/fly910905/article/details/82054196)

优点：

- 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
- 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。
- 可以根据自身业务特性分配bit位，非常灵活。

缺点：

- **强依赖机器时钟，如果机器上时钟回拨**，会导致发号重复或者服务会处于不可用状态

### 1. uuid于snowflake对比：

参考链接：[腾讯云-UUID和雪花(Snowflake)算法该如何选择？](https://cloud.tencent.com/developer/article/1766264)

uuid一般可用于生成 `Request ID` 来标记单次请求，但是如果用它来作为数据库主键，它会存在以下几点问题。

1）排序 

​		uuid不具备有序。

2）有序ID会提升数据的写入性能

我们知道 `MySQL` `InnoDB` 存储引擎使用 `B+` 树存储索引数据，而主键也是一种索引。索引数据在 `B+` 树中是有序排列的

3）uuid不具备业务含义

### 2. snowflake存在的疑问：

问题1：原生的Snowflake算法是完全依赖于时间的，如果有==时钟回拨==的情况发生，会生成重复的ID，市场上的解决方案也是非常多的：**（NTP时间校准--导致时间回退、任务重启导致时间回退）**

- 最简单的方案，就是关闭生成唯一ID机器的时间同步。
- 使用阿里云的的时间服务器进行同步，2017年1月1日的闰秒调整，阿里云服务器NTP系统24小时“消化”闰秒，完美解决了问题。
- 如果发现有时钟回拨，时间很短比如5毫秒,就等待，然后再生成。或者就直接报错，交给业务层去处理。
- 可以找2bit位作为时钟回拨位，发现有时钟回拨就将回拨位加1，达到最大位后再从0开始进行循环。

保存过去一段时间内`每一台机器在当前这一毫秒产生的ID的最大值`，比如使用Map形式，就是<machine_id,max_id>，这样如果某台机器发生了时钟回拨，直接在这台机器对应的max_id的基础上继续自增生成ID即可。

问题2：不同城市之间，基于城市再做区分？ 数据id+机器id=1024

问题3：基于MAC地址计算数据id和机器id。

问题4：trackid <=> uuid，id的显示。